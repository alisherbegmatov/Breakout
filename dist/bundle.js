/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/*!************************!*\
  !*** ./src/scripts.js ***!
  \************************/
eval("// VARIABLES\nconst canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d');\n\n// VARIABLE | X AND Y POSITIONS\nlet x = canvas.width / 2;\nlet y = canvas.height - 30;\n\n// VARIABLE | BALL VELOCITY\nlet dx = 2;\nlet dy = -2;\nconst ballRadius = 10;\n\n// VARIABLE | X AND Y PADDLE\nconst paddleHeight = 10;\nconst paddleWidth = 75;\nlet paddleX = (canvas.width - paddleWidth) / 2;\n\n// VARIABLE | KEYS PRESSED\nlet rightPressed = false;\nlet leftPressed = false;\n\n// VARIABLE | SCORE\nlet score = 0;\n\n// VARIABLE | LIVES\nlet lives = 5;\n\n// VARIABLE | BRICK INFORMATION\nconst brickRowCount = 5;\nconst brickColumnCount = 8;\nconst brickWidth = 45;\nconst brickHeight = 20;\nconst brickPadding = 10;\nconst brickOffsetTop = 30;\nconst brickOffsetLeft = 30;\nconst bricks = [];\nfor (let c = 0; c < brickColumnCount; c++) {\n  bricks[c] = [];\n  for (let r = 0; r < brickRowCount; r++) {\n    bricks[c][r] = { x: 0, y: 0, status: 1 };\n  }\n}\n\n// EVENT LISTENERS\ndocument.addEventListener('keydown', keyDownHandler, false);\ndocument.addEventListener('keyup', keyUpHandler, false);\ndocument.addEventListener('mousemove', mouseMoveHandler, false);\n\n// FUNCTION | BACKGROUND COLOR\nfunction drawBackground() {\n  document.body.style.backgroundColor = 'White';\n}\n\n// FUNCTION | KEYS DOWN HANDLER\nfunction keyDownHandler(e) {\n  if (e.key == 'Right' || e.key == 'ArrowRight') {\n    rightPressed = true;\n  } else if (e.key == 'Left' || e.key == 'ArrowLeft') {\n    leftPressed = true;\n  }\n}\n// FUNCTION | KEYS UP HANDLER\nfunction keyUpHandler(e) {\n  if (e.key == 'Right' || e.key == 'ArrowRight') {\n    rightPressed = false;\n  } else if (e.key == 'Left' || e.key == 'ArrowLeft') {\n    leftPressed = false;\n  }\n}\n// FUNCTION | MOUSE MOVE HANDLER\nfunction mouseMoveHandler(e) {\n  const relativeX = e.clientX - canvas.offsetLeft;\n  if (relativeX > (paddleWidth / 2) && relativeX < canvas.width - (paddleWidth / 2)) {\n    paddleX = relativeX - paddleWidth / 2;\n  }\n}\n// FUNCTION | COLISION DETECTION\nfunction collisionDetection() {\n  for (let c = 0; c < brickColumnCount; c++) {\n    for (let r = 0; r < brickRowCount; r++) {\n      const b = bricks[c][r];\n      if (b.status == 1) {\n        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {\n          dy = -dy;\n          b.status = 0;\n          score++;\n          if (score == brickRowCount * brickColumnCount) {\n            alert('YOU WIN, CONGRATULATIONS!');\n            document.location.reload();\n          }\n        }\n      }\n    }\n  }\n}\n\n// FUNCTION | DRAW SCORE\nfunction drawScore() {\n  ctx.font = '14px Futura';\n  ctx.fillStyle = '#000000';\n  ctx.fillText(`SCORE ${score}`, 8, 20);\n}\n// FUNCTION | DRAW LIVES\nfunction drawLives() {\n  ctx.font = '14px Futura';\n  ctx.fillStyle = '#000000';\n  ctx.fillText(`LIVES ${lives}`, canvas.width - 65, 20);\n}\n// FUNCTION | DRAW BALL\nfunction drawBall() {\n  ctx.beginPath();\n  ctx.arc(x, y, ballRadius, 0, Math.PI * 2);\n  ctx.fillStyle = '#';\n  ctx.fill();\n  ctx.closePath();\n}\n// FUNCTION | DRAW PADDLE\nfunction drawPaddle() {\n  ctx.beginPath();\n  ctx.rect(\n    paddleX,\n    canvas.height - paddleHeight,\n    paddleWidth,\n    paddleHeight,\n  );\n  ctx.fillStyle = '#';\n  ctx.fill();\n  ctx.closePath();\n}\n\n// FUNCTION | DRAW BRICKS\nfunction drawBricks() {\n  for (let c = 0; c < brickColumnCount; c++) {\n    for (let r = 0; r < brickRowCount; r++) {\n      if (bricks[c][r].status == 1) {\n        const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;\n        const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;\n        bricks[c][r].x = brickX;\n        bricks[c][r].y = brickY;\n        ctx.beginPath();\n        ctx.rect(brickX, brickY, brickWidth, brickHeight);\n        ctx.fillStyle = `rgb(${Math.floor(255 - 42.5 * c)}, ${\n          Math.floor(255 - 42.5 * r)}, 0)`;\n        ctx.fill();\n      }\n    }\n    ctx.fill();\n  } ctx.closePath();\n}\n\n// FUNCTION | DRAW\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  drawBall();\n  drawPaddle();\n  drawBricks();\n  collisionDetection();\n  drawScore();\n  drawLives();\n  drawBackground();\n\n  if(x + dx > canvas.width-ballRadius || x + dx < ballRadius) {\n    dx = -dx;\n  }\n\n  if (y + dy < ballRadius) {\n    dy = -dy;\n  }\n  else if(y + dy > canvas.height-ballRadius) {\n    if(x > paddleX && x < paddleX + paddleWidth) {\n      dy = -dy;\n    } else {\n      lives--;\n      if (!lives) {\n        alert('GAME OVER!');\n        document.location.reload();\n      } else {\n        x = canvas.width / 2;\n        y = canvas.height - 30;\n        dx = 2;\n        dy = -2;\n        paddleX = (canvas.width - paddleWidth) / 2;\n      }\n    }\n  }\n\n  if (rightPressed) {\n    paddleX += 7;\n    if (paddleX + paddleWidth > canvas.width) {\n      paddleX = canvas.width - paddleWidth;\n    }\n  } else if (leftPressed) {\n    paddleX -= 7;\n    if (paddleX < 0) {\n      paddleX = 0;\n    }\n  }\n  x += dx;\n  y += dy;\n  requestAnimationFrame(draw);\n}\n\ndraw();\n\n\n//# sourceURL=webpack://Breakout/./src/scripts.js?");
/******/ })()
;